{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"KMP算法详解\"\nintro:      \"\"\ndate:       2020-5-8 11:00:00\nauthor:     \"Makinohara\"\ncatalog: true\ntags:\n    - 计算机基础\n---\n\n## KMP理论概要\n\nKMP字符串匹配算法是一种效率更高的字符串匹配算法。相比于传统算法，由于其主串指针不需要回溯，因此大大减少了匹配需要的时间。\n\n首先，让我们看看其是如何减少重复的步骤的：\n\n假如有一字符串S：\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | c    | a    | a    | b    | a    |\n\n我们想要让字符串“aaba”与其匹配。\n\n那么，匹配看起来就是这样：\n\n第一次匹配：\n\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\n| a    | a    | b    | **a(不匹配)** |      |      |      |      |\n\n此时指针回退，主串指针回退至2，模式串回退至1。\n\n第二次匹配：\n\n| 1    | 2    | 3               | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | --------------- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | **b**           | c    | a    | a    | b    | a    |\n|      | a    | **a（不匹配）** |      |      |      |      |      |\n\n此时主串指针再次回退。\n\n可以看出，我们的主串指针在匹配过程中一直在重复读取某一段内容，这是大大有损效率的。若是能使主串指针不回退，只控制模式串指针回退一段距离，这也许可以改善。\n\n实际上，第二次匹配可以简化为：\n\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\n|      |      |      | **a(不匹配)** |      |      |      |      |\n\n然后是第三次匹配：\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8               |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --------------- |\n| a    | a    | b    | c    | a    | a    | b    | **a**           |\n|      |      |      |      | a    | a    | b    | **a(匹配成功)** |\n\n那么，如何算出模式串指针应当回退多少呢？\n\n根据KMP算法的核心思想，模式串T拥有一个对应表，用于记录模式串T重复的部分。\n\n观察以下两个对应表：\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | a    | a    | a    | b    | a    |\n| 0    | 1    | 2    | 1    | 2    | 3    | 3    | 4    |\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | b    | c    | d    | e    | f    | g    | h    |\n| 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |\n\n可以看出，1号表格中，在匹配到第8个位置时，若是不匹配，只需要回到4对应的位置继续匹配就可以了，但是2号表格中，每一次匹配都必须要回到位置1重新匹配。\n\n\n\n原因在于此：\n\n| 1       | 2       | 3       | 4    | 5       | 6       | 7       | 8    |\n| ------- | ------- | ------- | ---- | ------- | ------- | ------- | ---- |\n| ***a*** | ***a*** | ***b*** | a    | ***a*** | ***a*** | ***b*** | a    |\n| 0       | 1       | 2       | 1    | 2       | 3       | 3       | 4    |\n\n可以看到，若是第8个字符不匹配并不影响前3个字符已经匹配成功的事实。因为5、6、7三个字符与1、2、3无异。既然我们已经匹配过a、b、c三个字符了，何必再匹配一次？\n\n举例说明：\n\n匹配 “aabaaaabcaabaaaba”与“aabaaaba”\n\n| 1       | 2       | 3       | 4    | 5        | 6        | 7        | 8              | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\n| ------- | ------- | ------- | ---- | -------- | -------- | -------- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a       | a       | b       | a    | a        | a        | b        | **c**          | a    | a    | b    | a    | a    | a    | b    | a    |\n| a       | a       | b       | a    | **a**    | **a**    | **b**    | **a(不匹配）** |      |      |      |      |      |      |      |      |\n| 与5相同 | 与6相同 | 与7相同 |      | **匹配** | **匹配** | **匹配** |                |      |      |      |      |      |      |      |      |\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8                 | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | a    | a    | a    | b    | **c**             | a    | a    | b    | a    | a    | a    | b    | a    |\n|      |      |      |      | a    | a    | b    | **a（继续匹配）** | a    | a    | b    | a    |      |      |      |      |\n\n可以看到，由于我们已经在匹配5、6、7三个字符时确定a、a、b三个字符是匹配的，那么我们就不需要在匹配前三个字符上浪费时间了。\n\n那么，我们已经知道了如何使用模式串的“特性数组”来减少匹配重复字符上的浪费，但是这个数组怎样计算出来呢？\n\n综合来看，我们计算此数组的目的就在于减少重复匹配，那么此数组的最大目的就是找出在制定字母之前有多少重复部分。\n\n如：aabaaaba\n\n| 1                                                            | 2                      | 3            | 4             | 5            | 6             | 7             | 8              |\n| ------------------------------------------------------------ | ---------------------- | ------------ | ------------- | ------------ | ------------- | ------------- | -------------- |\n| a                                                            | a                      | b            | a             | a            | a             | b             | a              |\n| 0（因为每次匹配都是先使指针+1再匹配，若是第一个字符就不匹配，那么就使指针位置为0，匹配时从第一个开始匹配。） | 1（无论有无重复都为1） | 2（重复了a） | 1（没有重复） | 2（重复了a） | 3（重复了aa） | 3（重复了aa） | 4（重复了aab） |\n\n由此，推导程序如下：\n\n```c++\nstd::vector<int> getNext(std::string in) {\n        std::vector<int> res(in.length() + 1);\n        int i = 1, j = 0;\n        res[1] = 0;\n        while (i < in.length()) {\n            if (j == 0 || in[j - 1] == in[i - 1]) {\n                i++;\n                j++;\n                res[i] = j;\n            } else\n                j = res[j];\n        }\n        return res;\n    }\n```\n\n## KMP再优化：\n\n我们已经看出KMP算法是如何减少重复匹配来减少匹配时间的。但是，是否有一种更优化的方法呢？\n\n观察以下字符串：\n\n"},"__N_SSG":true}